#include <iostream>
#include <filesystem>
#include <sstream>

#include "Parser/Parser.h"
#include "Helpers/FileHelper.hpp"
#include "BuildGeneration/RegistrationFile.hpp"

#include "Config.hpp"
#include "FileUtils.hpp"
#include "Filewatch.hpp"
#include "cxxopts/include/cxxopts.hpp"

const std::string CMakeFile = "CMakeLists.txt";
const std::regex AutoGeneratedRegex("^(?!auto-generated.*)(.*\.(h|hpp))$");

void GenerateIntrospection(const std::filesystem::path& inputPath, const std::filesystem::path& outputPath)
{
	std::stringstream output;
	AP::Parser parser;
	{
		auto translationUnitDesc = parser.Parse(inputPath.string());
		AP::RegistrationFile file;
		file.Write(output, translationUnitDesc);
	}
	auto content = output.str();

	if (!content.empty())
	{
		if (!std::filesystem::exists(outputPath))
		{
			std::filesystem::create_directories(outputPath.parent_path());
		}

		std::fstream outputFileStream(outputPath, std::fstream::in | std::fstream::out | std::fstream::trunc);
		outputFileStream << content;
		outputFileStream.close();
	}
}

void WatchFileSystem(cxxopts::ParseResult& result)
{
	APT::Filewatch watch(
		APT::GetAbsoluteRootPath().string(),
		AutoGeneratedRegex,
		[](const APT::Filewatch::FilewatchEventContext& ctx, const APT::Filewatch::Event changeType) {
			std::cout << ctx.path << " : ";
			auto path = APT::GetPathOfGeneratedFile(ctx.path);

			switch (changeType)
			{
				/*case APT::Filewatch::Event::Added:
					std::cout << "The file was added to the directory." << '\n';
					break;*/
			case APT::Filewatch::Event::Removed:
				std::cout << "The file was removed from the directory." << '\n';
				std::filesystem::remove(path);
				break;
			case APT::Filewatch::Event::Added:
			case APT::Filewatch::Event::Modified:
			{
				GenerateIntrospection(APT::GetAbsoluteRootPath() / ctx.path, path);
			}
			break;
			case APT::Filewatch::Event::Renamed:
				std::cout << "The file was renamed and this is the old name " << ctx.oldPath << '\n';
				break;
			};
		}
	);

	while (true) {}
}

void IterateHeaderFiles() 
{
	auto srcPath = APT::GetAbsoluteRootPath();
	for (const auto& entry : std::filesystem::recursive_directory_iterator(srcPath))
	{
		auto isAutoGenerated = std::find_if(entry.path().begin(), entry.path().end(), [](const std::filesystem::path& pathSegment) {return pathSegment.string() == APT::GeneratedOutputFolder; }) != entry.path().end();
		auto extension = entry.path().extension();
		if (entry.is_regular_file() && (extension == ".h" || extension == ".hpp"))
		{
			std::cout << entry.path() << std::endl;
			auto entryPath = AP::ReplacePath(entry.path(), srcPath, srcPath / "auto-generated");
			auto outputPath = entryPath.replace_extension(std::filesystem::path("cpp"));
			GenerateIntrospection(entry.path(), outputPath);
		}
	}
}

int main(int argc, char* argv[])
{
	cxxopts::Options options("Amber Parser", "Reflection code generation");

	options.add_options()
		("src", "Root of the source code", cxxopts::value<std::string>())
		("watch", "Watch file system", cxxopts::value<bool>()->default_value("false"));

	//std::filesystem::create_directory(APT::GeneratedOutputFolder);

	auto result = APT::Init(argc, argv, options);

	if (result["watch"].as<bool>())
	{
		WatchFileSystem(result);
	}
	else 
	{
		IterateHeaderFiles();
	}
}